"""Tests for the RobloxExploitDefenseTransformer class.

This test suite covers:
- Initialization and configuration
- Runtime generation for exploit defense
- AST transformation at various injection points
- Pattern obfuscation for exploit-targeted globals
- Integrity checks and hash computation
- Edge cases and integration with other transformers
"""

import ast
import unittest
from unittest.mock import MagicMock, patch

# Try to import luaparser for Lua tests
try:
    from luaparser import ast as lua_ast
    from luaparser import astnodes as lua_nodes
    LUAPARSER_AVAILABLE = True
except ImportError:
    LUAPARSER_AVAILABLE = False

from obfuscator.processors.ast_transformer import (
    RobloxExploitDefenseTransformer,
    TransformResult,
)
from obfuscator.processors.roblox_exploit_runtime_lua import (
    generate_roblox_exploit_defense_checks,
)


def lua_skip(func):
    """Decorator to skip Lua tests when luaparser is not available."""
    return unittest.skipUnless(LUAPARSER_AVAILABLE, "luaparser not available")(func)


class TestRobloxExploitDefenseInit(unittest.TestCase):
    """Tests for RobloxExploitDefenseTransformer initialization."""

    def test_default_initialization(self):
        """Test default initialization (aggressiveness=2, language_mode="lua")."""
        transformer = RobloxExploitDefenseTransformer()
        self.assertEqual(transformer.aggressiveness, 2)
        self.assertEqual(transformer.language_mode, "lua")

    def test_initialization_with_config(self):
        """Test initialization with config object extracting roblox_exploit_aggressiveness option."""
        config = MagicMock()
        config.options = {"roblox_exploit_aggressiveness": 3}
        transformer = RobloxExploitDefenseTransformer(config=config)
        self.assertEqual(transformer.aggressiveness, 3)

    def test_explicit_parameter_override(self):
        """Test explicit parameter override of config values."""
        config = MagicMock()
        config.options = {"roblox_exploit_aggressiveness": 1}
        transformer = RobloxExploitDefenseTransformer(
            config=config, aggressiveness=3
        )
        self.assertEqual(transformer.aggressiveness, 3)

    def test_aggressiveness_validation_low(self):
        """Test aggressiveness validation and clamping (0→1)."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=0)
        self.assertEqual(transformer.aggressiveness, 1)

    def test_aggressiveness_validation_high(self):
        """Test aggressiveness validation and clamping (5→3)."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=5)
        self.assertEqual(transformer.aggressiveness, 3)

    def test_aggressiveness_non_integer(self):
        """Test non-integer aggressiveness handling (defaults to 2)."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness="invalid")
        self.assertEqual(transformer.aggressiveness, 2)


class TestRobloxExploitDefenseRuntimeGeneration(unittest.TestCase):
    """Tests for Lua runtime generation."""

    @lua_skip
    def test_inject_roblox_runtime_returns_list(self):
        """Test _inject_roblox_runtime() returns list of Lua AST nodes."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        nodes = transformer._inject_roblox_runtime()
        self.assertIsInstance(nodes, list)
        self.assertGreater(len(nodes), 0)

    @lua_skip
    def test_runtime_contains_executor_detection(self):
        """Test runtime contains exploit executor detection functions."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        nodes = transformer._inject_roblox_runtime()
        source = lua_ast.to_lua_source(lua_nodes.Chunk(body=lua_nodes.Block(body=nodes)))
        self.assertIn("_exploit_detect_0x2b4c", source)

    @lua_skip
    def test_runtime_contains_defensive_action(self):
        """Test runtime contains defensive action function."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        nodes = transformer._inject_roblox_runtime()
        source = lua_ast.to_lua_source(lua_nodes.Chunk(body=lua_nodes.Block(body=nodes)))
        self.assertIn("_roblox_defensive_0x5a7b", source)

    @lua_skip
    def test_runtime_contains_main_check(self):
        """Test runtime contains main check function."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        nodes = transformer._inject_roblox_runtime()
        source = lua_ast.to_lua_source(lua_nodes.Chunk(body=lua_nodes.Block(body=nodes)))
        self.assertIn("_roblox_check_0x1f3a", source)

    @lua_skip
    def test_runtime_contains_integrity_checks_at_level_2(self):
        """Test aggressiveness level 2+ includes integrity check functions."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        nodes = transformer._inject_roblox_runtime()
        source = lua_ast.to_lua_source(lua_nodes.Chunk(body=lua_nodes.Block(body=nodes)))
        self.assertIn("_integrity_verify_0x3d5e", source)
        self.assertIn("_compute_hash_0x6c8d", source)

    @lua_skip
    def test_runtime_contains_env_fingerprinting_at_level_3(self):
        """Test aggressiveness level 3 includes environment fingerprinting."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=3)
        nodes = transformer._inject_roblox_runtime()
        source = lua_ast.to_lua_source(lua_nodes.Chunk(body=lua_nodes.Block(body=nodes)))
        self.assertIn("_env_fingerprint_0x4f6a", source)

    @lua_skip
    def test_get_injected_function_names_level_1(self):
        """Test get_injected_function_names() returns correct list for aggressiveness=1."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=1)
        names = transformer.get_injected_function_names()
        self.assertIn("_roblox_check_0x1f3a", names)
        self.assertIn("_exploit_detect_0x2b4c", names)
        self.assertNotIn("_integrity_verify_0x3d5e", names)
        self.assertNotIn("_env_fingerprint_0x4f6a", names)

    @lua_skip
    def test_get_injected_function_names_level_2(self):
        """Test get_injected_function_names() returns correct list for aggressiveness=2."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        names = transformer.get_injected_function_names()
        self.assertIn("_roblox_check_0x1f3a", names)
        self.assertIn("_exploit_detect_0x2b4c", names)
        self.assertIn("_integrity_verify_0x3d5e", names)
        self.assertNotIn("_env_fingerprint_0x4f6a", names)

    @lua_skip
    def test_get_injected_function_names_level_3(self):
        """Test get_injected_function_names() returns correct list for aggressiveness=3."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=3)
        names = transformer.get_injected_function_names()
        self.assertIn("_roblox_check_0x1f3a", names)
        self.assertIn("_exploit_detect_0x2b4c", names)
        self.assertIn("_integrity_verify_0x3d5e", names)
        self.assertIn("_env_fingerprint_0x4f6a", names)

    @lua_skip
    def test_runtime_code_is_parseable(self):
        """Test runtime code is parseable by lua_ast.parse()."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        runtime_code = generate_roblox_exploit_defense_checks(aggressiveness=2)
        try:
            lua_ast.parse(runtime_code)
        except Exception as e:
            self.fail(f"Generated runtime code is not parseable: {e}")


class TestRobloxExploitDefenseTransformation(unittest.TestCase):
    """Tests for Lua AST transformation."""

    @lua_skip
    def test_transformation_injects_runtime_at_module_level(self):
        """Test transformation of Lua Chunk injects runtime at module level."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local x = 1"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

        # Check that runtime was injected
        source = lua_ast.to_lua_source(result.ast_node)
        self.assertIn("_roblox_check_0x1f3a", source)

    @lua_skip
    def test_entry_level_check_call_injected(self):
        """Test entry-level check call is injected after runtime statements."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local x = 1"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

        source = lua_ast.to_lua_source(result.ast_node)
        self.assertIn("_roblox_check_0x1f3a()", source)

    @lua_skip
    def test_function_entry_injection_at_level_2(self):
        """Test function entry injection at aggressiveness >= 2."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "function foo() return 1 end"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

        # Should have function entry check
        self.assertTrue(transformer._should_inject_at_function_entry())

    @lua_skip
    def test_no_function_entry_injection_at_level_1(self):
        """Test no function entry injection at aggressiveness = 1."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=1)
        self.assertFalse(transformer._should_inject_at_function_entry())

    @lua_skip
    def test_loop_entry_injection_at_level_3(self):
        """Test loop entry injection at aggressiveness >= 3."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=3)
        code = "while true do end"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)
        self.assertTrue(transformer._should_inject_at_critical_points())

    @lua_skip
    def test_no_loop_entry_at_level_2(self):
        """Test no loop entry injection at aggressiveness = 2."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        self.assertFalse(transformer._should_inject_at_critical_points())

    @lua_skip
    def test_transformation_count_accuracy(self):
        """Test transformation count accuracy."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        # Runtime + entry call + 1 function check
        code = "function foo() return 1 end"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)
        self.assertGreater(result.transformation_count, 0)

    def test_python_ast_skipped_gracefully(self):
        """Test Python AST is skipped gracefully."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "def foo(): pass"
        tree = ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)
        self.assertEqual(result.transformation_count, 0)

    def test_invalid_ast_node_returns_failure(self):
        """Test invalid AST node returns failure with error message."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)

        # Create a mock node that will cause an error
        class FakeNode:
            pass

        result = transformer.transform(FakeNode())
        self.assertFalse(result.success)
        self.assertGreater(len(result.errors), 0)


class TestRobloxExploitDefensePatternObfuscation(unittest.TestCase):
    """Tests for pattern obfuscation functionality."""

    @lua_skip
    def test_generate_indirection_stubs(self):
        """Test _generate_indirection_stubs() creates local aliases for sensitive globals."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local x = game"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

        # Check for indirection patterns
        source = lua_ast.to_lua_source(result.ast_node)
        self.assertIn("game", source)

    @lua_skip
    def test_obfuscate_exploit_patterns(self):
        """Test _obfuscate_exploit_patterns() rewrites direct global references."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local g = game"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)
        # Should increase transformation count
        self.assertGreaterEqual(result.transformation_count, 0)

    @lua_skip
    def test_pattern_obfuscation_increases_count(self):
        """Test pattern obfuscation increases transformation count."""
        transformer1 = RobloxExploitDefenseTransformer(aggressiveness=1)
        transformer2 = RobloxExploitDefenseTransformer(aggressiveness=2)

        code = "local g = game\nlocal w = workspace"
        tree = lua_ast.parse(code)

        result1 = transformer1.transform(tree)
        result2 = transformer2.transform(tree)

        # Level 2 should have more transformations
        self.assertGreaterEqual(result2.transformation_count, result1.transformation_count)


class TestRobloxExploitDefenseIntegrityChecks(unittest.TestCase):
    """Tests for integrity check functionality."""

    def test_compute_script_hash_consistency(self):
        """Test _compute_script_hash() produces consistent hash for same input."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        source = "local x = 1\nprint(x)"

        hash1 = transformer._compute_script_hash(source)
        hash2 = transformer._compute_script_hash(source)

        self.assertEqual(hash1, hash2)

    def test_compute_script_hash_different_inputs(self):
        """Test different inputs produce different hashes."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        source1 = "local x = 1"
        source2 = "local x = 2"

        hash1 = transformer._compute_script_hash(source1)
        hash2 = transformer._compute_script_hash(source2)

        self.assertNotEqual(hash1, hash2)

    @lua_skip
    def test_script_hash_computed_at_level_2(self):
        """Test script hash is computed from source code at aggressiveness >= 2."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local x = 1"
        tree = lua_ast.parse(code)

        # Transform to trigger hash computation
        result = transformer.transform(tree)
        self.assertTrue(result.success)

        # Hash should be computed after transformation
        self.assertIsNotNone(transformer.script_hash)

    @lua_skip
    def test_runtime_includes_hash_value(self):
        """Test runtime includes hash value in integrity check function."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local x = 1"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

        source = lua_ast.to_lua_source(result.ast_node)
        self.assertIn("_integrity_verify_0x3d5e", source)


class TestRobloxExploitDefenseEdgeCases(unittest.TestCase):
    """Tests for edge cases."""

    @lua_skip
    def test_empty_lua_chunk(self):
        """Test empty Lua chunk (no functions)."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = ""
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

    @lua_skip
    def test_lua_chunk_with_local_functions(self):
        """Test Lua chunk with only local functions."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local function foo() return 1 end\nlocal function bar() return 2 end"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

    @lua_skip
    def test_nested_functions(self):
        """Test nested functions (outer and inner both get checks at aggressiveness >= 2)."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "function outer()\n  function inner()\n    return 1\n  end\n  return inner()\nend"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)
        self.assertGreaterEqual(result.transformation_count, 2)

    @lua_skip
    def test_coroutines(self):
        """Test coroutines (should handle without errors)."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local co = coroutine.create(function() return 1 end)"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)

    @lua_skip
    def test_tables_and_metatables(self):
        """Test Lua chunk with tables and metatables."""
        transformer = RobloxExploitDefenseTransformer(aggressiveness=2)
        code = "local t = {}\nsetmetatable(t, {})\nreturn t"
        tree = lua_ast.parse(code)

        result = transformer.transform(tree)
        self.assertTrue(result.success)


class TestRobloxExploitDefenseIntegration(unittest.TestCase):
    """Tests for integration with other transformers."""

    @lua_skip
    def test_compatibility_with_anti_debugging(self):
        """Test compatibility with AntiDebuggingTransformer."""
        from obfuscator.processors.ast_transformer import AntiDebuggingTransformer

        code = "function foo() return 1 end"
        tree = lua_ast.parse(code)

        # Apply anti-debug first
        anti_debug = AntiDebuggingTransformer(anti_debug_aggressiveness=2)
        result1 = anti_debug.transform(tree)
        self.assertTrue(result1.success)

        # Then apply roblox defense
        roblox = RobloxExploitDefenseTransformer(aggressiveness=2)
        result2 = roblox.transform(result1.ast_node)
        self.assertTrue(result2.success)

    @lua_skip
    def test_compatibility_with_vm_protection(self):
        """Test compatibility with VMProtectionTransformer."""
        from obfuscator.processors.ast_transformer import VMProtectionTransformer

        code = "function foo() return 1 + 2 end"
        tree = lua_ast.parse(code)

        # Apply roblox defense
        roblox = RobloxExploitDefenseTransformer(aggressiveness=2)
        result1 = roblox.transform(tree)
        self.assertTrue(result1.success)

    @lua_skip
    def test_compatibility_with_string_encryption(self):
        """Test compatibility with string encryption."""
        from obfuscator.processors.ast_transformer import StringEncryptionTransformer

        code = 'local msg = "hello"\nfunction foo() return msg end'
        tree = lua_ast.parse(code)

        # Apply string encryption
        string_enc = StringEncryptionTransformer()
        result1 = string_enc.transform(tree)

        # Apply roblox defense
        roblox = RobloxExploitDefenseTransformer(aggressiveness=2)
        result2 = roblox.transform(result1.ast_node)
        self.assertTrue(result2.success)

    @lua_skip
    def test_compatibility_with_number_obfuscation(self):
        """Test compatibility with number obfuscation."""
        from obfuscator.processors.ast_transformer import NumberObfuscationTransformer

        code = "local x = 42\nfunction foo() return x end"
        tree = lua_ast.parse(code)

        # Apply number obfuscation
        num_obf = NumberObfuscationTransformer()
        result1 = num_obf.transform(tree)

        # Apply roblox defense
        roblox = RobloxExploitDefenseTransformer(aggressiveness=2)
        result2 = roblox.transform(result1.ast_node)
        self.assertTrue(result2.success)

    def test_full_pipeline_with_multiple_transformers(self):
        """Test full pipeline with multiple transformers enabled."""
        from obfuscator.core.obfuscation_engine import ObfuscationEngine
        from obfuscator.core.config import ObfuscationConfig

        config = ObfuscationConfig(
            name="test",
            preset="maximum",
            language="lua",
            features={"roblox_exploit_defense": True, "roblox_exploit_aggressiveness": 2},
        )
        engine = ObfuscationEngine(config)

        code = "function foo()\n  return 1\nend"

        # Apply transformations
        result = engine.apply_transformations(code, "lua", "test.lua")
        self.assertTrue(result.success)


if __name__ == "__main__":
    unittest.main()
