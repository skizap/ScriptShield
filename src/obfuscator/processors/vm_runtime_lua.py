"""
Lua VM Runtime Generator for VM Protection.

This module generates the Lua interpreter runtime code that executes
the custom bytecode generated by the VM protection transformer.
"""


def generate_lua_vm_runtime(bytecode_obfuscation: bool = False) -> str:
    """
    Generate Lua VM interpreter runtime code.
    
    Args:
        bytecode_obfuscation: Whether to include bytecode obfuscation
        
    Returns:
        Lua code string containing the VM runtime
    """
    runtime = f'''
-- Lua VM Runtime for Protected Bytecode Execution
-- Generated by ScriptShield Obfuscator

local VMRuntimeError = {{}}
VMRuntimeError.__index = VMRuntimeError

function VMRuntimeError:new(message)
    local error = {{}}
    setmetatable(error, VMRuntimeError)
    error.message = message or "VM Runtime Error"
    return error
end

function VMRuntimeError:__tostring()
    return "VMRuntimeError: " .. self.message
end


-- Bytecode VM Implementation
local BytecodeVM = {{}}
BytecodeVM.__index = BytecodeVM

-- Opcode definitions
BytecodeVM.LOAD_CONST = 0x01
BytecodeVM.LOAD_VAR = 0x02
BytecodeVM.STORE_VAR = 0x03
BytecodeVM.BINARY_ADD = 0x04
BytecodeVM.BINARY_SUB = 0x05
BytecodeVM.BINARY_MUL = 0x06
BytecodeVM.BINARY_DIV = 0x07
BytecodeVM.BINARY_MOD = 0x08
BytecodeVM.BINARY_POW = 0x09
BytecodeVM.COMPARE_EQ = 0x0A
BytecodeVM.COMPARE_NE = 0x0B
BytecodeVM.COMPARE_LT = 0x0C
BytecodeVM.COMPARE_LE = 0x0D
BytecodeVM.COMPARE_GT = 0x0E
BytecodeVM.COMPARE_GE = 0x0F
BytecodeVM.JUMP = 0x10
BytecodeVM.JUMP_IF_FALSE = 0x11
BytecodeVM.JUMP_IF_TRUE = 0x12
BytecodeVM.CALL_FUNC = 0x13
BytecodeVM.RETURN = 0x14
BytecodeVM.POP = 0x15
BytecodeVM.DUP = 0x16
BytecodeVM.LOAD_GLOBAL = 0x17
BytecodeVM.STORE_GLOBAL = 0x18
BytecodeVM.LOAD_ATTR = 0x19
BytecodeVM.STORE_ATTR = 0x1A
BytecodeVM.BUILD_LIST = 0x1B
BytecodeVM.BUILD_MAP = 0x1C
BytecodeVM.LOAD_INDEX = 0x1D
BytecodeVM.STORE_INDEX = 0x1E
BytecodeVM.UNARY_NOT = 0x1F
BytecodeVM.UNARY_NEGATIVE = 0x20
BytecodeVM.UNARY_POSITIVE = 0x21

function BytecodeVM:new(bytecode, constants, num_locals, globals_dict)
    local vm = {{}}
    setmetatable(vm, BytecodeVM)
    
    vm.bytecode = bytecode or {{}}
    vm.constants = constants or {{}}
    vm.num_locals = num_locals or 0
    vm.globals_dict = globals_dict or {{}}
    
    -- Execution state
    vm.stack = {{}}
    vm.locals = {{}}
    for i = 1, vm.num_locals do
        vm.locals[i] = nil
    end
    vm.ip = 1  -- Instruction pointer (1-based for Lua)
    
    -- For jump resolution
    vm.labels = {{}}
    
    return vm
end

function BytecodeVM:_fetch()
    if self.ip > #self.bytecode then
        error(VMRuntimeError:new("Unexpected end of bytecode"))
    end
    local value = self.bytecode[self.ip]
    self.ip = self.ip + 1
    return value
end

function BytecodeVM:_decode_arg()
    local arg_type = self:_fetch()
    
    if arg_type == 0 then  -- None/nil
        return nil
    elseif arg_type == 1 then  -- number
        return self:_fetch()
    elseif arg_type == 2 then  -- string
        local length = self:_fetch()
        local chars = {{}}
        for i = 1, length do
            chars[i] = string.char(self:_fetch())
        end
        return table.concat(chars)
    elseif arg_type == 3 then  -- constant pool index
        local idx = self:_fetch()
        return idx
    else
        error(VMRuntimeError:new("Unknown argument type: " .. tostring(arg_type)))
    end
end

function BytecodeVM:execute()
    while self.ip <= #self.bytecode do
        local opcode = self:_fetch()
        
        local handler = self:_dispatch(opcode)
        if handler == nil then
            error(VMRuntimeError:new("Unknown opcode: " .. string.format("0x%02X", opcode)))
        end
        
        local success, result = pcall(handler, self)
        if not success then
            error(VMRuntimeError:new("VM execution error at ip=" .. (self.ip-1) .. ": " .. tostring(result)))
        end
        
        if opcode == self.RETURN then
            return result
        end
    end
    
    return nil
end

function BytecodeVM:_dispatch(opcode)
    local dispatch_map = {{
        [self.LOAD_CONST] = self._op_load_const,
        [self.LOAD_VAR] = self._op_load_var,
        [self.STORE_VAR] = self._op_store_var,
        [self.BINARY_ADD] = self._op_binary_add,
        [self.BINARY_SUB] = self._op_binary_sub,
        [self.BINARY_MUL] = self._op_binary_mul,
        [self.BINARY_DIV] = self._op_binary_div,
        [self.BINARY_MOD] = self._op_binary_mod,
        [self.BINARY_POW] = self._op_binary_pow,
        [self.COMPARE_EQ] = self._op_compare_eq,
        [self.COMPARE_NE] = self._op_compare_ne,
        [self.COMPARE_LT] = self._op_compare_lt,
        [self.COMPARE_LE] = self._op_compare_le,
        [self.COMPARE_GT] = self._op_compare_gt,
        [self.COMPARE_GE] = self._op_compare_ge,
        [self.JUMP] = self._op_jump,
        [self.JUMP_IF_FALSE] = self._op_jump_if_false,
        [self.JUMP_IF_TRUE] = self._op_jump_if_true,
        [self.CALL_FUNC] = self._op_call_func,
        [self.RETURN] = self._op_return,
        [self.POP] = self._op_pop,
        [self.DUP] = self._op_dup,
        [self.LOAD_GLOBAL] = self._op_load_global,
        [self.STORE_GLOBAL] = self._op_store_global,
        [self.LOAD_ATTR] = self._op_load_attr,
        [self.STORE_ATTR] = self._op_store_attr,
        [self.BUILD_LIST] = self._op_build_list,
        [self.BUILD_MAP] = self._op_build_map,
        [self.LOAD_INDEX] = self._op_load_index,
        [self.STORE_INDEX] = self._op_store_index,
        [self.UNARY_NOT] = self._op_unary_not,
        [self.UNARY_NEGATIVE] = self._op_unary_negative,
        [self.UNARY_POSITIVE] = self._op_unary_positive,
    }}
    
    return dispatch_map[opcode]
end

-- Opcode handlers
function BytecodeVM:_op_load_const()
    local const_idx = self:_decode_arg()
    table.insert(self.stack, self.constants[const_idx + 1])  -- Lua is 1-based
end

function BytecodeVM:_op_load_var()
    local var_idx = self:_decode_arg()
    if var_idx >= #self.locals then
        error(VMRuntimeError:new("Local variable index out of range: " .. var_idx))
    end
    table.insert(self.stack, self.locals[var_idx + 1])
end

function BytecodeVM:_op_store_var()
    local var_idx = self:_decode_arg()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in STORE_VAR"))
    end
    if var_idx >= #self.locals then
        error(VMRuntimeError:new("Local variable index out of range: " .. var_idx))
    end
    self.locals[var_idx + 1] = table.remove(self.stack)
end

function BytecodeVM:_op_load_global()
    local var_name = self:_decode_arg()
    table.insert(self.stack, self.globals_dict[var_name])
end

function BytecodeVM:_op_store_global()
    local var_name = self:_decode_arg()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in STORE_GLOBAL"))
    end
    self.globals_dict[var_name] = table.remove(self.stack)
end

function BytecodeVM:_op_binary_add()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in BINARY_ADD"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left + right)
end

function BytecodeVM:_op_binary_sub()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in BINARY_SUB"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left - right)
end

function BytecodeVM:_op_binary_mul()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in BINARY_MUL"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left * right)
end

function BytecodeVM:_op_binary_div()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in BINARY_DIV"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left / right)
end

function BytecodeVM:_op_binary_mod()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in BINARY_MOD"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left % right)
end

function BytecodeVM:_op_binary_pow()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in BINARY_POW"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left ^ right)
end

function BytecodeVM:_op_compare_eq()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in COMPARE_EQ"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left == right)
end

function BytecodeVM:_op_compare_ne()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in COMPARE_NE"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left ~= right)
end

function BytecodeVM:_op_compare_lt()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in COMPARE_LT"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left < right)
end

function BytecodeVM:_op_compare_le()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in COMPARE_LE"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left <= right)
end

function BytecodeVM:_op_compare_gt()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in COMPARE_GT"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left > right)
end

function BytecodeVM:_op_compare_ge()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in COMPARE_GE"))
    end
    local right = table.remove(self.stack)
    local left = table.remove(self.stack)
    table.insert(self.stack, left >= right)
end

function BytecodeVM:_op_jump()
    local offset = self:_decode_arg()
    if type(offset) == "number" then
        self.ip = offset + 1  -- Convert to 1-based
    end
end

function BytecodeVM:_op_jump_if_false()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in JUMP_IF_FALSE"))
    end
    
    local condition = table.remove(self.stack)
    local offset = self:_decode_arg()
    
    if not condition then
        if type(offset) == "number" then
            self.ip = offset + 1
        end
    end
end

function BytecodeVM:_op_jump_if_true()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in JUMP_IF_TRUE"))
    end
    
    local condition = table.remove(self.stack)
    local offset = self:_decode_arg()
    
    if condition then
        if type(offset) == "number" then
            self.ip = offset + 1
        end
    end
end

function BytecodeVM:_op_call_func()
    local arg_count = self:_decode_arg() or 0
    
    if #self.stack < arg_count + 1 then
        error(VMRuntimeError:new("Stack underflow in CALL_FUNC"))
    end
    
    -- Pop arguments
    local args = {{}}
    for i = 1, arg_count do
        args[i] = table.remove(self.stack)
    end
    
    -- Reverse arguments to correct order
    for i = 1, math.floor(arg_count / 2) do
        args[i], args[arg_count - i + 1] = args[arg_count - i + 1], args[i]
    end
    
    -- Pop function
    local func = table.remove(self.stack)
    
    -- Call function
    local success, result = pcall(func, table.unpack(args, 1, arg_count))
    if not success then
        error(VMRuntimeError:new("Function call failed: " .. tostring(result)))
    end
    
    table.insert(self.stack, result)
end

function BytecodeVM:_op_return()
    if #self.stack > 0 then
        return table.remove(self.stack)
    end
    return nil
end

function BytecodeVM:_op_pop()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in POP"))
    end
    table.remove(self.stack)
end

function BytecodeVM:_op_dup()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in DUP"))
    end
    table.insert(self.stack, self.stack[#self.stack])
end

function BytecodeVM:_op_load_attr()
    local attr_name = self:_decode_arg()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in LOAD_ATTR"))
    end
    local obj = table.remove(self.stack)
    table.insert(self.stack, obj[attr_name])
end

function BytecodeVM:_op_store_attr()
    local attr_name = self:_decode_arg()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in STORE_ATTR"))
    end
    local value = table.remove(self.stack)
    local obj = table.remove(self.stack)
    obj[attr_name] = value
end

function BytecodeVM:_op_build_list()
    local count = self:_decode_arg() or 0
    if #self.stack < count then
        error(VMRuntimeError:new("Stack underflow in BUILD_LIST"))
    end
    
    local elements = {{}}
    for i = 1, count do
        elements[i] = table.remove(self.stack)
    end
    
    -- Reverse to correct order
    for i = 1, math.floor(count / 2) do
        elements[i], elements[count - i + 1] = elements[count - i + 1], elements[i]
    end
    
    table.insert(self.stack, elements)
end

function BytecodeVM:_op_build_map()
    local count = self:_decode_arg() or 0
    if #self.stack < count * 2 then
        error(VMRuntimeError:new("Stack underflow in BUILD_MAP"))
    end
    
    local result = {{}}
    for i = 1, count do
        local value = table.remove(self.stack)
        local key = table.remove(self.stack)
        result[key] = value
    end
    
    table.insert(self.stack, result)
end

function BytecodeVM:_op_load_index()
    if #self.stack < 2 then
        error(VMRuntimeError:new("Stack underflow in LOAD_INDEX"))
    end
    local index = table.remove(self.stack)
    local obj = table.remove(self.stack)
    table.insert(self.stack, obj[index])
end

function BytecodeVM:_op_store_index()
    if #self.stack < 3 then
        error(VMRuntimeError:new("Stack underflow in STORE_INDEX"))
    end
    local value = table.remove(self.stack)
    local index = table.remove(self.stack)
    local obj = table.remove(self.stack)
    obj[index] = value
end

function BytecodeVM:_op_unary_not()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in UNARY_NOT"))
    end
    table.insert(self.stack, not table.remove(self.stack))
end

function BytecodeVM:_op_unary_negative()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in UNARY_NEGATIVE"))
    end
    table.insert(self.stack, -table.remove(self.stack))
end

function BytecodeVM:_op_unary_positive()
    if #self.stack == 0 then
        error(VMRuntimeError:new("Stack underflow in UNARY_POSITIVE"))
    end
    table.insert(self.stack, table.remove(self.stack))
end


-- Utility function to execute protected functions
function execute_protected_function(bytecode, constants, num_locals, ...)
    local args = {{...}}
    local globals_dict = _G or {{}}
    
    -- Create VM instance
    local vm = BytecodeVM:new(bytecode, constants, num_locals, globals_dict)
    
    -- Set up local variables from function arguments
    for i = 1, math.min(#args, num_locals) do
        vm.locals[i] = args[i]
    end
    
    -- Execute and return results
    local result = vm:execute()
    
    -- Handle multiple return values if needed
    if type(result) == "table" and result.multiple then
        return table.unpack(result.values)
    end
    
    return result
end


-- Bytecode obfuscation utilities (if enabled)
local function obfuscate_bytecode(bytecode, key)
    -- Simple XOR obfuscation
    local obfuscated = {{}}
    local key_len = #key
    for i = 1, #bytecode do
        obfuscated[i] = bit32.bxor(bytecode[i], string.byte(key, ((i-1) % key_len) + 1))
    end
    return obfuscated
end

local function deobfuscate_bytecode(obfuscated_bytecode, key)
    -- XOR is symmetric
    return obfuscate_bytecode(obfuscated_bytecode, key)
end


-- Test function
local function _test_vm()
    -- Simple bytecode: load constant 42, return
    local bytecode = {{
        0x01, 1, 0, 1, 42, 0,  -- LOAD_CONST 42
        0x14, 0, 0, 0, 0, 0,   -- RETURN
    }}
    local constants = {{42}}
    
    local vm = BytecodeVM:new(bytecode, constants, 0)
    local result = vm:execute()
    
    assert(result == 42, string.format("Expected 42, got %s", tostring(result)))
    print("Lua VM test passed!")
end


-- Return the module
return {{
    BytecodeVM = BytecodeVM,
    execute_protected_function = execute_protected_function,
    VMRuntimeError = VMRuntimeError,
    _test_vm = _test_vm,
    obfuscate_bytecode = obfuscate_bytecode,
    deobfuscate_bytecode = deobfuscate_bytecode,
}}
'''
    
    return runtime


def generate_minified_lua_runtime(bytecode_obfuscation: bool = False) -> str:
    """
    Generate minified Lua VM runtime (smaller but less readable).
    
    Args:
        bytecode_obfuscation: Whether to include bytecode obfuscation
        
    Returns:
        Minified Lua code string
    """
    # This is a simplified minified version
    # In production, you'd want a proper minifier
    runtime = generate_lua_vm_runtime(bytecode_obfuscation)
    
    # Remove comments and extra whitespace
    lines = runtime.split('\n')
    minified_lines = []
    
    for line in lines:
        stripped = line.strip()
        
        # Skip empty lines
        if not stripped:
            continue
        
        # Skip comment lines
        if stripped.startswith('--') and not stripped.startswith('--[['):
            continue
        
        # Skip long comment blocks
        if stripped.startswith('--[['):
            continue
        
        minified_lines.append(line)
    
    return '\n'.join(minified_lines)


def get_lua_runtime_size(bytecode_obfuscation: bool = False) -> int:
    """
    Get the size of the Lua VM runtime in bytes.
    
    Args:
        bytecode_obfuscation: Whether to include bytecode obfuscation
        
    Returns:
        Size of runtime code in bytes
    """
    runtime = generate_lua_vm_runtime(bytecode_obfuscation)
    return len(runtime.encode('utf-8'))


def get_minified_lua_runtime_size(bytecode_obfuscation: bool = False) -> int:
    """
    Get the size of the minified Lua VM runtime in bytes.
    
    Args:
        bytecode_obfuscation: Whether to include bytecode obfuscation
        
    Returns:
        Size of minified runtime code in bytes
    """
    runtime = generate_minified_lua_runtime(bytecode_obfuscation)
    return len(runtime.encode('utf-8'))