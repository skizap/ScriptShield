"""
Python VM Runtime Generator for VM Protection.

This module generates the Python interpreter runtime code that executes
the custom bytecode generated by the VM protection transformer.
"""

import textwrap
from typing import Optional


def generate_python_vm_runtime(bytecode_encryption: bool = False) -> str:
    """
    Generate Python VM interpreter runtime code.
    
    Args:
        bytecode_encryption: Whether to include bytecode encryption/decryption
        
    Returns:
        Python code string containing the VM runtime
    """
    runtime = f'''
import struct
import sys
from typing import List, Any, Dict, Optional, Tuple


class VMRuntimeError(Exception):
    """Exception raised when VM execution fails."""
    pass


class BytecodeVM:
    """
    Virtual Machine for executing custom bytecode.
    
    This VM uses a stack-based architecture with a separate
    local variable array for function execution.
    """
    
    # Bytecode opcodes
    LOAD_CONST = 0x01
    LOAD_VAR = 0x02
    STORE_VAR = 0x03
    BINARY_ADD = 0x04
    BINARY_SUB = 0x05
    BINARY_MUL = 0x06
    BINARY_DIV = 0x07
    BINARY_MOD = 0x08
    BINARY_POW = 0x09
    COMPARE_EQ = 0x0A
    COMPARE_NE = 0x0B
    COMPARE_LT = 0x0C
    COMPARE_LE = 0x0D
    COMPARE_GT = 0x0E
    COMPARE_GE = 0x0F
    JUMP = 0x10
    JUMP_IF_FALSE = 0x11
    JUMP_IF_TRUE = 0x12
    CALL_FUNC = 0x13
    RETURN = 0x14
    POP = 0x15
    DUP = 0x16
    LOAD_GLOBAL = 0x17
    STORE_GLOBAL = 0x18
    LOAD_ATTR = 0x19
    STORE_ATTR = 0x1A
    BUILD_LIST = 0x1B
    BUILD_MAP = 0x1C
    LOAD_INDEX = 0x1D
    STORE_INDEX = 0x1E
    UNARY_NOT = 0x1F
    UNARY_NEGATIVE = 0x20
    UNARY_POSITIVE = 0x21
    
    def __init__(self, bytecode: List[int], constants: List[Any], num_locals: int, 
                 globals_dict: Optional[Dict[str, Any]] = None):
        """
        Initialize VM with bytecode and execution context.
        
        Args:
            bytecode: Serialized bytecode instructions
            constants: Constant pool for literals
            num_locals: Number of local variables
            globals_dict: Global variable namespace
        """
        self.bytecode = bytecode
        self.constants = constants
        self.num_locals = num_locals
        self.globals_dict = globals_dict or {{}}
        
        # Execution state
        self.stack: List[Any] = []
        self.locals: List[Any] = [None] * num_locals
        self.ip = 0  # Instruction pointer
        
        # For jump resolution
        self.labels: Dict[str, int] = {{}}
        self._resolve_labels()
        
        # Bytecode encryption key (if enabled)
        self.encryption_key = b'vm_encrypt_key_2024' if {bytecode_encryption} else None
    
    def _resolve_labels(self):
        """Resolve label positions in bytecode for jumps."""
        # In a real implementation, we'd scan for label markers
        # For now, labels are resolved during execution
        pass
    
    def _fetch(self) -> int:
        """Fetch next byte from bytecode."""
        if self.ip >= len(self.bytecode):
            raise VMRuntimeError("Unexpected end of bytecode")
        value = self.bytecode[self.ip]
        self.ip += 1
        return value
    
    def _decode_arg(self) -> Any:
        """Decode an argument from bytecode."""
        arg_type = self._fetch()
        
        if arg_type == 0:  # None
            return None
        elif arg_type == 1:  # int
            return self._fetch()
        elif arg_type == 2:  # str
            length = self._fetch()
            chars = [self._fetch() for _ in range(length)]
            return bytes(chars).decode('utf-8')
        elif arg_type == 3:  # constant pool index
            idx = self._fetch()
            return idx
        else:
            raise VMRuntimeError(f"Unknown argument type: {{arg_type}}")
    
    def execute(self) -> Any:
        """
        Execute the bytecode and return the result.
        
        Returns:
            The return value from the executed function
        """
        while self.ip < len(self.bytecode):
            opcode = self._fetch()
            
            # Dispatch to opcode handler
            handler = self._dispatch(opcode)
            if handler is None:
                raise VMRuntimeError(f"Unknown opcode: {{opcode:02X}}")
            
            try:
                result = handler()
                if opcode == self.RETURN:
                    return result
            except Exception as e:
                raise VMRuntimeError(f"VM execution error at ip={{self.ip-1}}: {{e}}")
        
        # If we reach here without explicit return, return None
        return None
    
    def _dispatch(self, opcode: int):
        """Dispatch opcode to handler method."""
        dispatch_map = {{
            self.LOAD_CONST: self._op_load_const,
            self.LOAD_VAR: self._op_load_var,
            self.STORE_VAR: self._op_store_var,
            self.BINARY_ADD: self._op_binary_add,
            self.BINARY_SUB: self._op_binary_sub,
            self.BINARY_MUL: self._op_binary_mul,
            self.BINARY_DIV: self._op_binary_div,
            self.BINARY_MOD: self._op_binary_mod,
            self.BINARY_POW: self._op_binary_pow,
            self.COMPARE_EQ: self._op_compare_eq,
            self.COMPARE_NE: self._op_compare_ne,
            self.COMPARE_LT: self._op_compare_lt,
            self.COMPARE_LE: self._op_compare_le,
            self.COMPARE_GT: self._op_compare_gt,
            self.COMPARE_GE: self._op_compare_ge,
            self.JUMP: self._op_jump,
            self.JUMP_IF_FALSE: self._op_jump_if_false,
            self.JUMP_IF_TRUE: self._op_jump_if_true,
            self.CALL_FUNC: self._op_call_func,
            self.RETURN: self._op_return,
            self.POP: self._op_pop,
            self.DUP: self._op_dup,
            self.LOAD_GLOBAL: self._op_load_global,
            self.STORE_GLOBAL: self._op_store_global,
            self.LOAD_ATTR: self._op_load_attr,
            self.STORE_ATTR: self._op_store_attr,
            self.BUILD_LIST: self._op_build_list,
            self.BUILD_MAP: self._op_build_map,
            self.LOAD_INDEX: self._op_load_index,
            self.STORE_INDEX: self._op_store_index,
            self.UNARY_NOT: self._op_unary_not,
            self.UNARY_NEGATIVE: self._op_unary_negative,
            self.UNARY_POSITIVE: self._op_unary_positive,
        }}
        return dispatch_map.get(opcode)
    
    # Opcode handlers
    def _op_load_const(self):
        """Load constant from constant pool."""
        const_idx = self._decode_arg()
        self.stack.append(self.constants[const_idx])
    
    def _op_load_var(self):
        """Load local variable."""
        var_idx = self._decode_arg()
        if var_idx >= len(self.locals):
            raise VMRuntimeError(f"Local variable index out of range: {{var_idx}}")
        self.stack.append(self.locals[var_idx])
    
    def _op_store_var(self):
        """Store to local variable."""
        var_idx = self._decode_arg()
        if not self.stack:
            raise VMRuntimeError("Stack underflow in STORE_VAR")
        if var_idx >= len(self.locals):
            raise VMRuntimeError(f"Local variable index out of range: {{var_idx}}")
        self.locals[var_idx] = self.stack.pop()
    
    def _op_load_global(self):
        """Load global variable."""
        var_name = self._decode_arg()
        self.stack.append(self.globals_dict.get(var_name))
    
    def _op_store_global(self):
        """Store to global variable."""
        var_name = self._decode_arg()
        if not self.stack:
            raise VMRuntimeError("Stack underflow in STORE_GLOBAL")
        self.globals_dict[var_name] = self.stack.pop()
    
    def _op_binary_add(self):
        """Binary addition."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in BINARY_ADD")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left + right)
    
    def _op_binary_sub(self):
        """Binary subtraction."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in BINARY_SUB")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left - right)
    
    def _op_binary_mul(self):
        """Binary multiplication."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in BINARY_MUL")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left * right)
    
    def _op_binary_div(self):
        """Binary division."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in BINARY_DIV")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left / right)
    
    def _op_binary_mod(self):
        """Binary modulo."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in BINARY_MOD")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left % right)
    
    def _op_binary_pow(self):
        """Binary power."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in BINARY_POW")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left ** right)
    
    def _op_compare_eq(self):
        """Equality comparison."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in COMPARE_EQ")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left == right)
    
    def _op_compare_ne(self):
        """Not-equal comparison."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in COMPARE_NE")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left != right)
    
    def _op_compare_lt(self):
        """Less-than comparison."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in COMPARE_LT")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left < right)
    
    def _op_compare_le(self):
        """Less-than-or-equal comparison."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in COMPARE_LE")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left <= right)
    
    def _op_compare_gt(self):
        """Greater-than comparison."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in COMPARE_GT")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left > right)
    
    def _op_compare_ge(self):
        """Greater-than-or-equal comparison."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in COMPARE_GE")
        right = self.stack.pop()
        left = self.stack.pop()
        self.stack.append(left >= right)
    
    def _op_jump(self):
        """Unconditional jump."""
        # For simplicity, we'll use relative jumps based on instruction count
        # In a real implementation, we'd have proper label resolution
        offset = self._decode_arg()
        if isinstance(offset, int):
            self.ip = offset
    
    def _op_jump_if_false(self):
        """Conditional jump if top of stack is false."""
        if not self.stack:
            raise VMRuntimeError("Stack underflow in JUMP_IF_FALSE")
        
        condition = self.stack.pop()
        offset = self._decode_arg()
        
        if not condition:
            if isinstance(offset, int):
                self.ip = offset
    
    def _op_jump_if_true(self):
        """Conditional jump if top of stack is true."""
        if not self.stack:
            raise VMRuntimeError("Stack underflow in JUMP_IF_TRUE")
        
        condition = self.stack.pop()
        offset = self._decode_arg()
        
        if condition:
            if isinstance(offset, int):
                self.ip = offset
    
    def _op_call_func(self):
        """Call a function."""
        arg_count = self._decode_arg() or 0
        
        if len(self.stack) < arg_count + 1:
            raise VMRuntimeError("Stack underflow in CALL_FUNC")
        
        # Pop arguments
        args = [self.stack.pop() for _ in range(arg_count)]
        args.reverse()
        
        # Pop function object
        func = self.stack.pop()
        
        # Call function and push result
        try:
            result = func(*args)
            self.stack.append(result)
        except Exception as e:
            raise VMRuntimeError(f"Function call failed: {{e}}")
    
    def _op_return(self):
        """Return from function."""
        if self.stack:
            return self.stack.pop()
        return None
    
    def _op_pop(self):
        """Pop top of stack."""
        if not self.stack:
            raise VMRuntimeError("Stack underflow in POP")
        self.stack.pop()
    
    def _op_dup(self):
        """Duplicate top of stack."""
        if not self.stack:
            raise VMRuntimeError("Stack underflow in DUP")
        self.stack.append(self.stack[-1])
    
    def _op_load_attr(self):
        """Load attribute from object."""
        attr_name = self._decode_arg()
        if not self.stack:
            raise VMRuntimeError("Stack underflow in LOAD_ATTR")
        obj = self.stack.pop()
        self.stack.append(getattr(obj, attr_name))
    
    def _op_store_attr(self):
        """Store attribute to object."""
        attr_name = self._decode_arg()
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in STORE_ATTR")
        value = self.stack.pop()
        obj = self.stack.pop()
        setattr(obj, attr_name, value)
    
    def _op_build_list(self):
        """Build a list from stack values."""
        count = self._decode_arg() or 0
        if len(self.stack) < count:
            raise VMRuntimeError("Stack underflow in BUILD_LIST")
        
        elements = [self.stack.pop() for _ in range(count)]
        elements.reverse()
        self.stack.append(elements)
    
    def _op_build_map(self):
        """Build a dict from stack values."""
        count = self._decode_arg() or 0
        if len(self.stack) < count * 2:
            raise VMRuntimeError("Stack underflow in BUILD_MAP")
        
        result = {{}}
        for _ in range(count):
            value = self.stack.pop()
            key = self.stack.pop()
            result[key] = value
        
        self.stack.append(result)
    
    def _op_load_index(self):
        """Load from subscript/index operation."""
        if len(self.stack) < 2:
            raise VMRuntimeError("Stack underflow in LOAD_INDEX")
        index = self.stack.pop()
        obj = self.stack.pop()
        self.stack.append(obj[index])
    
    def _op_store_index(self):
        """Store to subscript/index operation."""
        if len(self.stack) < 3:
            raise VMRuntimeError("Stack underflow in STORE_INDEX")
        value = self.stack.pop()
        index = self.stack.pop()
        obj = self.stack.pop()
        obj[index] = value
    
    def _op_unary_not(self):
        """Unary not operation."""
        if not self.stack:
            raise VMRuntimeError("Stack underflow in UNARY_NOT")
        self.stack.append(not self.stack.pop())
    
    def _op_unary_negative(self):
        """Unary negative operation."""
        if not self.stack:
            raise VMRuntimeError("Stack underflow in UNARY_NEGATIVE")
        self.stack.append(-self.stack.pop())
    
    def _op_unary_positive(self):
        """Unary positive operation."""
        if not self.stack:
            raise VMRuntimeError("Stack underflow in UNARY_POSITIVE")
        self.stack.append(+self.stack.pop())


def execute_protected_function(bytecode: List[int], constants: List[Any], 
                               num_locals: int, *args, **kwargs) -> Any:
    """
    Execute a protected function with the given bytecode.
    
    Args:
        bytecode: Serialized bytecode instructions
        constants: Constant pool
        num_locals: Number of local variables
        *args: Function arguments
        **kwargs: Additional keyword arguments (including globals)
    
    Returns:
        Function return value
    """
    # Create VM instance
    vm = BytecodeVM(bytecode, constants, num_locals, kwargs.get('globals_dict'))
    
    # Set up local variables from function arguments
    for i, arg in enumerate(args):
        if i < num_locals:
            vm.locals[i] = arg
    
    # Execute and return result
    return vm.execute()


# Utility functions for bytecode manipulation
def encrypt_bytecode(bytecode: List[int], key: bytes) -> List[int]:
    """
    Encrypt bytecode using XOR with key.
    
    Args:
        bytecode: Bytecode to encrypt
        key: Encryption key
    
    Returns:
        Encrypted bytecode
    """
    key_len = len(key)
    return [(b ^ key[i % key_len]) for i, b in enumerate(bytecode)]


def decrypt_bytecode(encrypted_bytecode: List[int], key: bytes) -> List[int]:
    """
    Decrypt bytecode using XOR with key.
    
    Args:
        encrypted_bytecode: Encrypted bytecode
        key: Encryption key
    
    Returns:
        Decrypted bytecode
    """
    # XOR is symmetric, same operation for encryption and decryption
    return encrypt_bytecode(encrypted_bytecode, key)


# Example usage and test function
def _test_vm():
    """Test the VM with a simple example."""
    # Simple bytecode: load constant 42, return
    bytecode = [
        0x01, 1, 0, 1, 42, 0,  # LOAD_CONST 42
        0x14, 0, 0, 0, 0, 0,   # RETURN
    ]
    constants = [42]
    
    vm = BytecodeVM(bytecode, constants, 0)
    result = vm.execute()
    assert result == 42, f"Expected 42, got {{result}}"
    print("VM test passed!")


if __name__ == "__main__":
    _test_vm()
'''
    
    return runtime


def generate_minified_python_runtime(bytecode_encryption: bool = False) -> str:
    """
    Generate minified Python VM runtime (smaller but less readable).
    
    Args:
        bytecode_encryption: Whether to include bytecode encryption/decryption
        
    Returns:
        Minified Python code string
    """
    # This is a simplified minified version
    # In production, you'd want a proper minifier
    runtime = generate_python_vm_runtime(bytecode_encryption)
    
    # Remove comments and docstrings
    lines = runtime.split('\n')
    minified_lines = []
    in_docstring = False
    
    for line in lines:
        stripped = line.strip()
        
        # Skip empty lines
        if not stripped:
            continue
        
        # Skip comment lines (but keep shebang and encoding)
        if stripped.startswith('#') and not stripped.startswith('#!'):
            continue
        
        # Skip docstring lines
        if stripped.startswith('"""') or stripped.startswith("'''"):
            if stripped.count('"""') == 1 or stripped.count("'''") == 1:
                in_docstring = not in_docstring
            continue
        
        if in_docstring:
            continue
        
        minified_lines.append(line)
    
    return '\n'.join(minified_lines)


def get_runtime_size(bytecode_encryption: bool = False) -> int:
    """
    Get the size of the VM runtime in bytes.
    
    Args:
        bytecode_encryption: Whether to include bytecode encryption
        
    Returns:
        Size of runtime code in bytes
    """
    runtime = generate_python_vm_runtime(bytecode_encryption)
    return len(runtime.encode('utf-8'))


def get_minified_runtime_size(bytecode_encryption: bool = False) -> int:
    """
    Get the size of the minified VM runtime in bytes.
    
    Args:
        bytecode_encryption: Whether to include bytecode encryption
        
    Returns:
        Size of minified runtime code in bytes
    """
    runtime = generate_minified_python_runtime(bytecode_encryption)
    return len(runtime.encode('utf-8'))