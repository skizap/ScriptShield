"""Roblox exploit defense runtime code generator for Lua.

This module generates Lua runtime code that detects common Roblox exploit
executors (Synapse X, KRNL, Script-Ware, etc.), performs script integrity
verification via hash checks, and fingerprints the execution environment.
"""

import textwrap
from typing import Optional


def generate_roblox_exploit_defense_checks(
    aggressiveness: int = 2,
    action: str = "exit",
    script_hash: Optional[int] = None,
) -> str:
    """Generate Lua Roblox exploit defense runtime code.

    Generates a suite of exploit detection functions that check for:
    - Exploit executor globals (syn, KRNL_LOADED, getgenv, getrawmetatable)
    - Common exploit functions (gethui, hookfunction, hookmetamethod)
    - Script integrity verification via hash comparison (aggressiveness >= 2)
    - Environment fingerprinting and metatable tampering (aggressiveness >= 3)

    Args:
        aggressiveness: Level of defense checks (1=minimal, 2=moderate, 3=aggressive)
        action: Defensive action when exploit detected ("exit", "loop", "exception")
        script_hash: Pre-computed hash of original script for integrity checks

    Returns:
        Lua code as a string containing all detection functions
    """
    # Define obfuscated function names
    main_check_name = "_roblox_check_0x1f3a"
    executor_detect_name = "_exploit_detect_0x2b4c"
    integrity_check_name = "_integrity_verify_0x3d5e"
    env_fingerprint_name = "_env_fingerprint_0x4f6a"
    defensive_action_name = "_roblox_defensive_0x5a7b"
    hash_func_name = "_compute_hash_0x6c8d"

    # Defensive action code based on selected action
    if action == "exit":
        action_code = "os.exit(1)"
    elif action == "loop":
        action_code = "while true do end"
    else:  # exception
        action_code = "error('Security violation detected')"

    code_parts = []

    # Defensive action function
    defensive_func = f"""local function {defensive_action_name}()
    -- Execute defensive action when exploit is detected
    {action_code}
end"""
    code_parts.append(defensive_func)
    code_parts.append("")

    # Exploit executor detection - always included
    executor_check = f"""local function {executor_detect_name}()
    -- Check for Synapse X
    if syn ~= nil or _G["syn"] ~= nil then
        {defensive_action_name}()
    end
    -- Check for KRNL
    if KRNL_LOADED ~= nil or _G["KRNL_LOADED"] ~= nil then
        {defensive_action_name}()
    end
    -- Check for Script-Ware / common exploit functions
    if getgenv ~= nil or getrawmetatable ~= nil then
        {defensive_action_name}()
    end
    -- Check for additional exploit executor functions
    local _exploit_funcs = {{
        'gethui', 'getloadedmodules', 'getcallingscript',
        'hookfunction', 'hookmetamethod'
    }}
    for _, _fname in ipairs(_exploit_funcs) do
        if _G[_fname] ~= nil then
            {defensive_action_name}()
        end
    end
end"""
    code_parts.append(executor_check)
    code_parts.append("")

    # Integrity checks - moderate and above
    if aggressiveness >= 2:
        hash_value = script_hash if script_hash is not None else 0
        integrity_check = f"""local function {hash_func_name}(str)
    local h = 0
    for i = 1, #str do
        h = (h * 31 + string.byte(str, i)) % 2147483647
    end
    return h
end

local function {integrity_check_name}()
    -- Verify script integrity via hash comparison
    local _expected_hash = {hash_value}
    if _expected_hash ~= 0 then
        local _ok, _source = pcall(function()
            if script and script.Source then
                return tostring(script.Source)
            end
            return nil
        end)
        if _ok and _source ~= nil then
            local _actual_hash = {hash_func_name}(_source)
            if _actual_hash ~= _expected_hash then
                {defensive_action_name}()
            end
        end
    end
end"""
        code_parts.append(integrity_check)
        code_parts.append("")

    # Environment fingerprinting - aggressive only
    if aggressiveness >= 3:
        env_fingerprint = f"""local function {env_fingerprint_name}()
    -- Verify expected Roblox globals exist and have correct types
    local _expected_globals = {{
        {{'game', 'userdata'}},
        {{'workspace', 'userdata'}},
        {{'script', 'userdata'}},
        {{'Instance', 'table'}}
    }}
    for _, _entry in ipairs(_expected_globals) do
        local _name, _expected_type = _entry[1], _entry[2]
        local _val = _G[_name]
        if _val == nil or type(_val) ~= _expected_type then
            {defensive_action_name}()
        end
    end
    -- Verify expected Roblox services exist
    local _ok1, _ = pcall(function() return game:GetService("Players") end)
    if not _ok1 then
        {defensive_action_name}()
    end
    local _ok2, _ = pcall(function() return game:GetService("Workspace") end)
    if not _ok2 then
        {defensive_action_name}()
    end
    -- Detect tampered metatables on core objects
    local _ok3, _mt_game = pcall(getmetatable, game)
    if _ok3 and _mt_game == nil then
        {defensive_action_name}()
    end
    local _ok4, _mt_ws = pcall(getmetatable, workspace)
    if _ok4 and _mt_ws == nil then
        {defensive_action_name}()
    end
    -- Check for unexpected global variables (suspicious entries in _G)
    local _suspicious_keys = {{
        'getgenv', 'getrenv', 'getreg', 'getgc',
        'firesignal', 'fireclickdetector', 'fireproximityprompt'
    }}
    for _, _key in ipairs(_suspicious_keys) do
        if _G[_key] ~= nil then
            {defensive_action_name}()
        end
    end
end"""
        code_parts.append(env_fingerprint)
        code_parts.append("")

    # Main check function that calls all checks
    checks_to_call = [executor_detect_name]
    if aggressiveness >= 2:
        checks_to_call.append(integrity_check_name)
    if aggressiveness >= 3:
        checks_to_call.append(env_fingerprint_name)

    if aggressiveness >= 3:
        # At aggressive level, add randomized check order
        checks_list = ",\n        ".join(checks_to_call)
        main_check = f"""local function {main_check_name}()
    -- Main Roblox exploit defense check function
    local _checks = {{
        {checks_list}
    }}
    -- Randomize check order to avoid pattern detection
    local _n = #_checks
    for _i = _n, 2, -1 do
        local _j = math.random(_i)
        _checks[_i], _checks[_j] = _checks[_j], _checks[_i]
    end
    for _, _check in ipairs(_checks) do
        local _ok, _ = pcall(_check)
        if not _ok then
            -- Ignore errors in individual checks
        end
    end
end"""
    else:
        # Standard sequential checks
        check_calls = "\n    ".join(f"{c}()" for c in checks_to_call)
        main_check = f"""local function {main_check_name}()
    -- Main Roblox exploit defense check function
    {check_calls}
end"""

    code_parts.append(main_check)

    return "\n\n".join(code_parts)
